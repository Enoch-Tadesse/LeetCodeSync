# for each node, create an array and keep track of how many other ways they can be affectes
# anyone who can be affected more than one way, can never be saved by removing a node
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial.sort()
        self.visited = set()
        self.aff = set(initial)
        largest = -1
        out = initial[0]
        for init in initial:
            if init in self.visited:
                continue
            self.visited.add(init)
            count, inf = self.traverse(init, graph)
            # print(f"outside {init=} {inf=} {count=}")
            if inf < 2:
                if count > largest:
                    largest = count
                    out = init
        return out
    def traverse(self, init, graph):
        stack = [init]
        count = inf = 1
        while stack:
            curr = stack.pop()
            for c in range(len(graph)):
                if graph[curr][c]:
                    if c in self.visited:
                        continue
                    # print(graph[curr][c], curr, c)
                    count += 1
                    # print(self.aff)
                    inf += c in self.aff
                    # print(inf)
                    self.visited.add(c)
                    stack.append(c)
        # print(f"inside {init=} {inf=} {count=}")

        return (count, inf)

